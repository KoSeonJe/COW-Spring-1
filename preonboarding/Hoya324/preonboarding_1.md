- **자바의 데이터 타입에 대해 작성해주세요.(Primitive vs Reference)**
    - **기본형 타입(Primitive type)**
        - Null 존재하지 않음
        - 실제 값을 저장하는 공간으로 스택 메모리에 저장
    - **참조형 타입(Reference type)**
      - 빈 객체를 의미하는 Null이 존재
      - 값이 저장되어있는 주소값을 저장하는 공간으로 힙 메모리에 저장된다.

    | 기본형 타입     | 할당되는 메모리 크기 | 기본값 | 데이터의 표현 범위 |
    |------------| --- | --- | --- |
    | 논리형        | boolean | 1 byte | false |
    | 정수형        | byte | 1 byte | 0 |
    | short      | 2 byte | 0 | -32,768 ~ 32,767 |
    | int(기본)    | 4 byte | 0 | -2,147,483,648 ~ 2,147,483,647 |
    | long       | 8 byte | 0L | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
    | 실수형        | float | 4 byte | 0.0F |
    | double(기본) | 8 byte | 0.0 | (1.7 X 10-308) ~ (1.7 X 10308) 의 근사값 |
    | 문자형        | char | 2 byte (유니코드) | '\u0000' |
    
    | 참조형 타입           | 예시                                                   | 기본값 | 할당되는 메모리 크기 |
    |------------------|------------------------------------------------------| --- | --- |
    | 배열(Array)        | int[] arr = new int[5];                              | Null | 4 byte (객체의 주소값) |
    | 열거(Enumeration)  |                                                      | Null |  |
    | 클래스(Class)       | String str = "test";  Student sujin = new Student(); | Null |  |
    | 인터페이스(Interface) |                                                      | Null |  |

- **자바의 접근제어자에 대해 작성해주세요.**
    - 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 4개의 접근 제어자로 제한하는 것을 말합니다.
    - 허용 범위 순서(뒤로 갈 수록 제한이 많아짐): ***public > protected > default > private***
    - **public 접근 제어자:** 접근 제한이 없음
    - **protected 접근 제어자:** 동일한 패키지 내에 존재하거나, 파생 클래스에서만 접근이 가능
    - ******default 접근 제어자:****** 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능
    - **private 접근 제어자:** 자기 자신의 클래스 내에서만 접근이 가능
- **static 키워드에 대해 작성해주세요.**
    - 정적(static)은 고정된이란 의미를 가지고 있다. Static이라는 키워드를 사용하여 Static변수와 Static메소드를 만들 수 있으며, 정적필드와 정적 메소드라고도 한다. 이 둘을 합쳐 정적 멤버(또는 클래스 멤버)라고 한다.
    - 정적 필드와 정적 메소드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버이다. 그렇기에 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나는 즉시 바로 사용할 수 있다.
- **final 키워드에 대해 작성해주세요.**
    - final 필드는 초기값이 저장되면 최종적인 값이 되어 프로그램 실행 도중에 수정을 할 수 없다.
    - 클래스에 final을 사용하게되면 그 클래스는 최종상태가 되어 더이상 상속이 불가능하다. final 클래스여도 필드는 Setter함수를 통하여 변경은 가능하다.
    - 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없다. 즉 한번 생성된 final 객체는 같은 타입으로 재생성이 불가능하다. 객체자체는 변경이 불가능하지만 객체 내부 변수는 변경 가능하다.
    - 메서드에 final을 사용하게되면 상속받은 클래스에서 부모의 final 메서드를 재정의 할 수 없다. 자신이 만든 메서드를 변경할 수 없게끔 하고싶을때 사용되며 시스템의 코어부분에서 변경을 원치 않는 메서드에 많이 구현되어 있다.
- **오버로딩(overloading)과 오버라이딩(overriding)에 대해 작성해주세요.**
    - 오버로딩(Overloading)
        - 기존에 없는 새로운 메서드를 정의하는 것이다.
    - 오버라이딩(Overriding)
        - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.
        - 자손 클래스 자신에 맞게 변경해야하는 경우에 오버라이드, 즉 덮어씌우는 것이다.
    - 오버라이딩 조건
      자식 클래스에서 오버라이딩하는 매서드는 부모 클래스의 메서드와
        1. 이름이 같아야 한다.
        2. 매개변수가 같아야 한다.
        3. 반환타입이 같아야 한다.
    - JDK 1.5부터 ‘공변 반환타입(covariant return type)’ 이 추가되어, 반환타입을 자식 클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화됨.
    - 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
        1. 접근 제어자(public, protected, (default), private)를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
        2. 예외는 조상 클래스의 베서드보다 많이 선언할 수 없다.
        3. 인스턴스메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.

      즉, 오버라이딩은

        1. 선언부 일치
        2. 조상 클래스보다 좁은 접근 제어자 사용 불가
        3. 조상 클래스보다 더 넓은 예외 사용 불가

      라는 조건을 가진다고 기억하면 된다.

    - **@Override는 어떤 용도인가?**
        - @Override에서 @는 어노테이션(Annotation)이라고 하며, 주석이라는 뜻이다. 우리가 알고있는 //과 같은 일반적인 주석과 다르게, 검증하는 기능을 한다. @Override는 여기서 오버라이딩을 검증하는 기능을 한다. 코드상으로 검사했을 때, 오버라이딩이 실제로 시행되지 않았다면 컴파일시 오류를 출력한다
    - 오버로딩 vs 오버라이딩
        - 오버로딩 (overloading) 기존에 없는 새로운 메서드를 정의하는 것
        - 오버라이딩(Overriding) 상속받은 메서드의 내용을 변경하는 것
- **추상 클래스와 인터페이스의 차이를 작성해주세요.**
    - 추상 클래스(Abstract Class) -> 객체들의 공통 특성들을 모아놓은 클래스
        - 상속하여 공통된 기능을 만들고, 확장하기 위함
        - 다중상속 불가능
        - 생성자와 일반변수 모두 가질 수 있다.
        - 메서드를 부분적으로 구현할 수 있다.
        - extends 키워드를 사용한다.
    - 인터페이스(Interface)-> 객체 생성을 위한 설계도
        - 구현하는 객체들이 같은 동작을 보장하기 위함
        - 다중상속 가능
        - 생성자와 일반변수를 가질 수 없다.
        - 메서드 선언만 가능하다.
        - implements 키워드를 사용한다
    - 추상 클래스는 많은 객체를 생성해야 할 때 각각의 객체에 공통점과 개발의 효율성을 위해 생성
    - 인터페이스는 수많은 개발자가 함께 협업을 할 때 객체 간의 통일성을 강제하기 위한 용도로 많이 사용
- **Enum에 대해 작성해주세요.**
    - enum 키워드는 열거 타입을 선언하기 위한 키워드입니다. 열거 타입(Season)이름을 지정하고 열거 상수(ex: 봄,여름,가을,겨울)를 나열하면 된다.
- **Generic에 대해 작성해주세요.**
    - 제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다.
    - **Generic(제네릭)의 장점**

      **1.** 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

      **2.** 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.

      **3.** 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

    - **제한된 Generic(제네릭)과 와일드 카드**
        - **extends T : 상한 경계(T 타입을 포함한 자식(자손) 타입만 가능)**
        - **? super T : 하한 경계(T 타입의 부모(조상) 타입만 가능)**
        - **<?> : 와일드 카드(Wild card)(어떤 타입이든 상관 없다)**

- **람다에 대해 작성해주세요.**
    - 람다 함수는 프로그래밍 언어에서 사용되는 개념으로 익명 함수(Anonymous functions)를 지칭하는 용어이다.
    - 람다 대수는 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법이다.
    - **장점**

        1. 코드의 간결성 - 람다를 사용하면 불필요한 반복문의 삭제가 가능하며 복잡한 식을 단순하게 표현할 수 있다.

        2. 지연연산 수행 - 람다는 지연연상을 수행 함으로써 불필요한 연산을 최소화 할 수 있다.

        3. 병렬처리 가능 - 멀티쓰레드를 활용하여 병렬처리를 사용 할 수 있다.

    - **단점**

        1. 람다식의 호출이 까다롭다.

        2. 람다 stream 사용 시 단순 for문 혹은 while문 사용 시 성능이 떨어진다.

        3. 불필요하게 너무 사용하게 되면 오히려 가독성을 떨어 뜨릴 수 있다.

    - **람다의 표현식**

        1. 람다는 매개변수 화살표(->) 함수몸체로 이용하여 사용 할 수 있습니다.

        2. 함수몸체가 단일 실행문이면 괄호{}를 생략 할 수 있습니다.

        3. 함수몸체가 return 문으로만 구성되어 있는 경우 괄호{}를 생략 할 수 없습니다.
